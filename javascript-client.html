<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Torus Node</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.training.wasm.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #sessionForm, #joinForm {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"],
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        button {
            background-color: #0066cc;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0052a3;
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        #log {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; }
    </style>
</head>
<body>
    <h2>WebRTC Torus Node</h2>
    
    <div id="sessionForm">
        <h3>Create New Session</h3>
        <div class="form-group">
            <label for="maxClients">Number of Clients:</label>
            <input type="number" id="maxClients" min="2" value="4">
        </div>
        <div class="form-group">
            <label for="sessionId">Session Code:</label>
            <input type="text" id="sessionId" placeholder="Enter session code">
        </div>
        <button onclick="createSession()">Create Session</button>
    </div>

    <div id="joinForm">
        <h3>Join Existing Session</h3>
        <div class="form-group">
            <label for="joinSessionId">Session Code:</label>
            <input type="text" id="joinSessionId" placeholder="Enter session code">
        </div>
        <button onclick="joinSession()">Join Session</button>
    </div>

    <div id="status">Status: Not Connected</div>
    <div id="log"></div>

    <script>
        //logging helper    
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `${new Date().toISOString()} - ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;

            if (type === 'info') {
                console.log(message);
            } else {
                console.error(message);
            }
        }

        class TorusNode {
            constructor(signalingServer) {
                this.signalingServer = signalingServer;
                this.connections = new Map();
                this.dataChannels = new Map();
                this.rank = null;
                this.neighbors = null;
                this.connectedPeers = new Set();
                this.pendingConnections = new Set();
                this.expectedConnections = 0;
                this.connectionRetries = new Map();
                this.MAX_RETRIES = 3;
                this.RETRY_DELAY = 2000;
                this.sessionId = null;

                this.artifact_path = "./public/training_artifacts/"
                this.isTraining = false;
                this.executionProviders = ['wasm'];

                log('Initializing TorusNode...');
            }

            /*
            
            Helpers

            */


            updateStatus(message) {
                document.getElementById('status').textContent = `Status: ${message}`;
            }

            /*
            
            Decentralized Communication

            */

            async connect(sessionInfo) {
                try {
                    this.ws = new WebSocket(this.signalingServer);
                    this.ws.onmessage = this.handleWsMessage.bind(this);
                    this.ws.onopen = () => {
                        log('Connected to signaling server');
                        this.ws.send(JSON.stringify({
                            // type: 'session_action',
                            type: sessionInfo.type,
                            sessionId: sessionInfo.sessionId,
                            maxClients: sessionInfo.maxClients,
                            clientType: 'javascript'
                        }));
                    };
                } catch (error) {
                    log(`WebSocket connection error: ${error}`, 'error');
                }
            }

            async handleWsMessage(event) {
                const data = JSON.parse(event.data);
                log(`Received ${data.type} message`);

                switch (data.type) {
                    case 'session_created':
                        this.updateStatus(`Session created. Waiting for ${data.remainingClients} more clients...`);
                        this.sessionId = data.sessionId;
                        break;
                    case 'session_joined':
                        this.updateStatus(`Joined session. Waiting for ${data.remainingClients} more clients...`);
                        this.sessionId = data.sessionId;
                        break;
                    case 'session_ready':
                        this.updateStatus('Session ready! Establishing connections...');
                        break;
                    case 'session_error':
                        this.updateStatus(`Session Error: ${data.message}`);
                        log(data.message, 'error');
                        break;
                    case 'topology':
                        await this.handleTopology(data);
                        break;
                    case 'signal':
                        await this.handleSignaling(data);
                        break;
                    case 'network_ready':
                        this.updateStatus('Network Ready');
                        break;
                }
            }

            async handleTopology(data) {
                this.rank = data.rank;
                const newNeighbors = data.neighbors;
                log(`Received topology. Rank: ${this.rank}, Neighbors: ${JSON.stringify(newNeighbors)}`);

                if (this.neighbors) {
                    const oldNeighbors = new Set(Object.values(this.neighbors));
                    const newNeighborSet = new Set(Object.values(newNeighbors));
                    for (const rank of oldNeighbors) {
                        if (!newNeighborSet.has(rank)) {
                            await this.cleanupConnection(rank);
                        }
                    }
                }

                this.neighbors = newNeighbors;
                this.expectedConnections = Object.keys(newNeighbors).length;
                this.updateStatus(`Connected (Rank ${this.rank})`);

                // Initiate connections to higher-ranked neighbors
                for (const neighborRank of Object.values(newNeighbors)) {
                    if (neighborRank > this.rank && 
                        !this.connections.has(neighborRank) && 
                        !this.pendingConnections.has(neighborRank)) {
                        log(`Initiating connection to ${neighborRank}`);
                        this.pendingConnections.add(neighborRank);
                        this.initiateConnection(neighborRank);
                    }
                }
            }

            createPeerConnection() {
                const config = {
                    iceServers: [{
                        urls: [
                            'stun:stun.l.google.com:19302',
                            'stun:stun1.l.google.com:19302'
                        ]
                    }]
                };

                const pc = new RTCPeerConnection(config);
                
                pc.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${pc.iceConnectionState}`);
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('ICE candidate generated');
                    }
                };

                return pc;
            }

            async initiateConnection(targetRank) {
                try {
                    const pc = this.createPeerConnection();
                    this.connections.set(targetRank, pc);

                    // Create data channel
                    const channel = pc.createDataChannel(`chat-${this.rank}-${targetRank}`);
                    this.setupDataChannel(channel, targetRank);

                    // Create and set local description
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);

                    // Wait for ICE gathering
                    await new Promise(resolve => {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                setTimeout(checkState, 1000);
                            }
                        };
                        checkState();
                    });

                    // Send offer
                    await this.sendSignaling(targetRank, {
                        type: 'offer',
                        sdp: pc.localDescription.sdp
                    });

                } catch (error) {
                    log(`Failed to initiate connection to ${targetRank}: ${error}`, 'error');
                    await this.handleConnectionFailure(targetRank);
                }
            }

            setupDataChannel(channel, peerRank) {
                this.dataChannels.set(peerRank, channel);

                channel.onopen = () => {
                    log(`Data channel opened with peer ${peerRank}`);
                    this.onPeerConnected(peerRank);
                    this.startFederatedTrainingLoop(peerRank);
                };

                channel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'ping') {
                            log(`Received ping from ${peerRank}`);
                            channel.send(JSON.stringify({
                                type: 'pong',
                                timestamp: data.timestamp,
                                respondedAt: Date.now()
                            }));
                        } else if (data.type === 'pong') {
                            const rtt = Date.now() - data.timestamp;
                            log(`Received pong from ${peerRank}, RTT: ${rtt}ms`);
                        } else if (data.type === "weights") { // handle recieved weights
                            log(`Recieved weights from ${peerRank}`);
                            this.importWeights(data.weights);
                        }
                    } catch (error) {
                        log(`Failed to parse message from ${peerRank}: ${error}`, 'error');
                    }
                };
            }

            /* Old Pinging Loop, Replace this w/ Training Loop
            startPingLoop(peerRank) {
                const sendPing = () => {
                    const channel = this.dataChannels.get(peerRank);
                    if (channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                };

                setInterval(sendPing, 5000);
            }
            */

            async startFederatedTrainingLoop(peerRank) {
                const trainAndSend = async () => {
                    try {
                        if (this.isTraining) {
                            log("training already in progress. skipping this iteration");
                            return;
                        }

                        this.isTraining = true;
                        log("starting training iteration...");

                        await this.train()

                        const channel = this.dataChannels.get(peerRank);
                        if (channel && channel.readyState === "open") {
                            channel.send(JSON.stringify({
                                type: "weights",
                                weights: await this.exportWeights(),
                                timestamp: Date.now()
                            }));
                            log(`Sent weights to ${peerRank}`);
                        }
                    } catch (error) {
                        log(`error during training: ${error}`);
                    } finally {
                        this.isTraining = false;
                    }
                }

                setInterval(trainAndSend, 5000);
            }



            async handleSignaling(message) {
                const senderRank = message.senderRank;
                const data = message.data;

                try {
                    let pc = this.connections.get(senderRank);
                    if (!pc) {
                        pc = this.createPeerConnection();
                        this.connections.set(senderRank, pc);

                        pc.ondatachannel = (event) => {
                            this.setupDataChannel(event.channel, senderRank);
                        };
                    }

                    if (data.type === 'offer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: data.sdp
                        }));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await this.sendSignaling(senderRank, {
                            type: 'answer',
                            sdp: answer.sdp,
                        });
                    } else if (data.type === 'answer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdp
                        }));
                    } else if (data.type === 'candidate') {
                        await pc.addIceCandidate({
                            candidate: data.candidate,
                            sdpMLineIndex: 0,
                            sdpMid: '0'
                        });
                    }
                } catch (error) {
                    log(`Error handling signaling message: ${error}`, 'error');
                }
            }

            async sendSignaling(targetRank, data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    await this.ws.send(JSON.stringify({
                        type: 'signal',
                        targetRank: targetRank,
                        data: data,
                        sessionId: this.sessionId
                    }));
                }
            }

            onPeerConnected(peerRank) {
                this.connectedPeers.add(peerRank);
                this.pendingConnections.delete(peerRank);
                log(`Connected to peer ${peerRank}. Connected: ${this.connectedPeers.size}/${this.expectedConnections}`);

                this.ws.send(JSON.stringify({
                    type: 'connection_established',
                    peerRank: peerRank,
                    sessionId: this.sessionId
                }));
            }

            async handleConnectionFailure(targetRank) {
                const retryCount = this.connectionRetries.get(targetRank) || 0;
                if (retryCount < this.MAX_RETRIES) {
                    this.connectionRetries.set(targetRank, retryCount + 1);
                    await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY * (retryCount + 1)));
                    if (!this.connectedPeers.has(targetRank)) {
                        await this.cleanupConnection(targetRank);
                        this.initiateConnection(targetRank);
                    }
                } else {
                    log(`Max retries reached for ${targetRank}`, 'error');
                    await this.cleanupConnection(targetRank);
                }
            }

            async cleanupConnection(rank) {
                try {
                    const pc = this.connections.get(rank);
                    if (pc) {
                        const channel = this.dataChannels.get(rank);
                        if (channel) {
                            channel.close();
                            this.dataChannels.delete(rank);
                        }
                        pc.close();
                        this.connections.delete(rank);
                    }

                    this.pendingConnections.delete(rank);
                    this.connectedPeers.delete(rank);
                    log(`Cleaned up connection to peer ${rank}`);
                } catch (error) {
                    log(`Error during connection cleanup for peer ${rank}: ${error}`, 'error');
                }
            }

            /*

            Begin Training Methods

            */

            async loadTrainingSession() {
                log("starting training session...")

                const chkptPath = this.artifact_path + "checkpoint";
                const trainingPath = this.artifact_path + 'training_model.onnx';
                const optimizerPath = this.artifact_path + 'optimizer_model.onnx';
                const evalPath = this.artifact_path + 'eval_model.onnx';

                const options = {
                    checkpointState: chkptPath,
                    trainModel: trainingPath,
                    evalModel: evalPath,
                    optimizerModel: optimizerPath,
                    optimizerConfig: {
                        name: "Adam",
                        learningRate: 0.001,
                        alpha: 0.9,
                        beta: 0.999,
                        epsilon: 1e-8
                    }
                };

                try {
                    this.session = await ort.TrainingSession.create(
                        options.trainModel,
                        options.evalModel,
                        {
                            optimizerModel: options.optimizerModel,
                            checkpointState: options.checkpointState,
                            ...options
                        }
                    );
                    log("training session successfully loaded.")
                    return this.session;
                } catch (err) {
                    log("error loading training session...")
                    throw err;
                }
            };

            
        

            async runTrainingEpoch(epoch) {
                let batchNum = 0;
                for await (const batch of this.dataSet.trainingBatches()) {
                    ++batchNum;

                    // create input
                    const feeds = {
                        input: batch.data,
                        labels: batch.labels
                    }

                    // call train step
                    const results = await this.session.runTrainStep(feeds);

                    // update weights then reset gradients
                    await this.session.runOptimizerStep();
                    await this.session.lazyResetGrad();
                }
            }

            async runTestingEpoch(epoch) {
                let batchNum = 0;
                let numCorrect = 0;
                let testPicsSoFar = 0;
                let accumulatedLoss = 0;
                for await (const batch of dataSet.testBatches()) {
                    ++batchNum;

                    // create input
                    const feeds = {
                        input: batch.data,
                        labels: batch.labels
                    }

                    // call eval step
                    const results = await this.session.runEvalStep(feeds);

                    // update UI with metrics
                    const loss = parseFloat(results[lossNodeName].data);
                    accumulatedLoss += loss;
                    testPicsSoFar += batch.data.dims[0];
                    numCorrect += countCorrectPredictions(results['output'], batch.labels);
                }
                const avgAcc = numCorrect / testPicsSoFar;
                log("average accuracy", avgAcc)
                return avgAcc;
            }

            async train(numEpochs=1) {
                log("loading data...")
                this.dataSet = new BloodMNIST(64);

                for (let epoch = 0; epoch < numEpochs; epoch++) {
                    await this.runTrainingEpoch(epoch);
                    await this.runTestingEpoch(epoch)
                }

                log("training complete...")
            }
            
            countCorrectPredictions(output, labels){
                let result = 0;
                const predictions = this.getPredictions(output);
                for (let i = 0; i < predictions.length; ++i) {
                    if (BigInt(predictions[i]) === labels.data[i]) {
                        ++result;
                    }
                }
                return result;
            }

            getPredictions(results) {
                const predictions = [];
                const [batchSize, numClasses] = results.dims;
                for (let i = 0; i < batchSize; ++i) {
                    const probabilities = results.data.slice(i * numClasses, (i + 1) * numClasses);
                    const resultsLabel = indexOfMax(probabilities);
                    predictions.push(resultsLabel);
                }
                return predictions;
            }

            indexOfMax(arr) {
                if (arr.length === 0) {
                    throw new Error('index of max (used in test accuracy function) expects a non-empty array. Something went wrong.');
                }

                let maxIndex = 0;
                for (let i = 1; i < arr.length; i++) {
                    if (arr[i] > arr[maxIndex]) {
                        maxIndex = i;
                    }
                }
                return maxIndex;
            }
        }

        /*

        Session Handling

        */

        let node = null;

        function createSession() {
            const maxClients = document.getElementById('maxClients').value;
            const sessionId = document.getElementById('sessionId').value || generateSessionId();
            document.getElementById('sessionId').value = sessionId;

            node = new TorusNode('ws://localhost:8080');
            node.connect({
                type: 'create_session',
                sessionId: sessionId,
                maxClients: parseInt(maxClients)
            });
        }

        function joinSession() {
            const sessionId = document.getElementById('joinSessionId').value;
            if (!sessionId) {
                alert('Please enter a session code');
                return;
            }

            node = new TorusNode('ws://localhost:8080');
            node.connect({
                type: 'join_session',
                sessionId: sessionId
            });
        }

        function generateSessionId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // Hide the forms once connected
        function hideSessionForms() {
            document.getElementById('sessionForm').style.display = 'none';
            document.getElementById('joinForm').style.display = 'none';
        }

        class BloodMNIST {
            constructor(batchSize = 64) {   
                this.BATCH_SIZE = batchSize;
                this.MAX_NUM_TRAIN_SAMPLES = 11959;
                this.MAX_NUM_TEST_SAMPLES = 2487;
                this.NUM_CHANNELS = 3;
                this.IMAGE_SIZE = 28;
                this.NUM_CLASSES = 8;
                this.PIXEL_MAX = 255;
                
                // RGB normalization constants for BloodMNIST
                this.PIXEL_MEANS = [0.7019, 0.5301, 0.5379];
                this.PIXEL_STDS = [0.2330, 0.2656, 0.2584];

                if (batchSize <= 0) {
                    throw new Error("batchSize must be > 0");
                }
            }

            getNumTrainingBatches() {
                return Math.floor(this.MAX_NUM_TRAIN_SAMPLES / this.BATCH_SIZE);
            }

            getNumTestBatches() {
                return Math.floor(this.MAX_NUM_TEST_SAMPLES / this.BATCH_SIZE);
            }

            normalizeChannel(pixelValue, channel) {
                return ((pixelValue / this.PIXEL_MAX) - this.PIXEL_MEANS[channel]) / this.PIXEL_STDS[channel];
            }

            async *getBatches(data, labels) {
                for (let i = 0; i < data.length; i++) {
                    yield {
                        data: data[i],
                        labels: labels[i]
                    };
                }
            }

            async loadData(jsonData, dataType, maxNumSamples, normalize = true) {
                const result = [];
                
                for (let i = 0; i < Math.min(jsonData[dataType].length, maxNumSamples); i += this.BATCH_SIZE) {
                    const batchEnd = Math.min(i + this.BATCH_SIZE, jsonData[dataType].length);
                    const batchSize = batchEnd - i;
                    
                    if (dataType === 'images') {
                        // Process image data
                        const batchData = new Float32Array(
                            batchSize * this.NUM_CHANNELS * this.IMAGE_SIZE * this.IMAGE_SIZE
                        );
                        
                        // Process each image in the batch
                        for (let j = 0; j < batchSize; j++) {
                            const image = jsonData.images[i + j];
                            
                            // Process each pixel
                            for (let c = 0; c < this.NUM_CHANNELS; c++) {
                                for (let h = 0; h < this.IMAGE_SIZE; h++) {
                                    for (let w = 0; w < this.IMAGE_SIZE; w++) {
                                        const pixelValue = image[h][w][c];
                                        const index = j * (this.NUM_CHANNELS * this.IMAGE_SIZE * this.IMAGE_SIZE) +
                                                    c * (this.IMAGE_SIZE * this.IMAGE_SIZE) +
                                                    h * this.IMAGE_SIZE + w;
                                        
                                        batchData[index] = normalize ? 
                                            this.normalizeChannel(pixelValue, c) : 
                                            pixelValue;
                                    }
                                }
                            }
                        }
                        
                        // Create tensor with shape [batch_size, channels, height, width]
                        result.push(new ort.Tensor(
                            'float32',
                            batchData,
                            [batchSize, this.NUM_CHANNELS, this.IMAGE_SIZE, this.IMAGE_SIZE]
                        ));
                        
                    } else {
                        // Process labels
                        const batchLabels = jsonData.labels
                            .slice(i, batchEnd)
                            .map(label => BigInt(label));
                        
                        result.push(new ort.Tensor(
                            'int64',
                            new BigInt64Array(batchLabels),
                            [batchSize]
                        ));
                    }
                }
                
                return result;
            }

            async *trainingBatches(normalize = true) {
                try {
                    const response = await fetch('public/data/bloodmnist_train.json');
                    const jsonData = await response.json();

                    log(JSON.stringify(jsonData))
                    
                    const trainingData = await this.loadData(jsonData, 'image', this.MAX_NUM_TRAIN_SAMPLES, normalize);
                    const trainingLabels = await this.loadData(jsonData, 'label', this.MAX_NUM_TRAIN_SAMPLES);
                    
                    yield* this.getBatches(trainingData, trainingLabels);
                } catch (error) {
                    console.error('Error loading training data:', error);
                    throw error;
                }
            }

            async *testBatches(normalize = true) {
                try {
                    const response = await fetch('public/data/bloodmnist_test.json');
                    const jsonData = await response.json();
                    
                    const testData = await this.loadData(jsonData, 'image', this.MAX_NUM_TEST_SAMPLES, normalize);
                    const testLabels = await this.loadData(jsonData, 'label', this.MAX_NUM_TEST_SAMPLES);
                    
                    yield* this.getBatches(testData, testLabels);
                } catch (error) {
                    console.error('Error loading test data:', error);
                    throw error;
                }
            }

            validateTensorShape(tensor, isData) {
                const shape = tensor.dims;
                if (isData) {
                    return shape.length === 4 && 
                        shape[1] === this.NUM_CHANNELS && 
                        shape[2] === this.IMAGE_SIZE && 
                        shape[3] === this.IMAGE_SIZE;
                }
                return shape.length === 1;
            }
        }
    </script>
</body>
</html>