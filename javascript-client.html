<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Torus Node</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.training.wasm.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #sessionForm, #joinForm {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"],
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        button {
            background-color: #0066cc;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0052a3;
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        #log {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; }
    </style>
</head>
<body>
    <h2>WebRTC Torus Node</h2>
    
    <div id="sessionForm">
        <h3>Create New Session</h3>
        <div class="form-group">
            <label for="maxClients">Number of Clients:</label>
            <input type="number" id="maxClients" min="2" value="4">
        </div>
        <div class="form-group">
            <label for="sessionId">Session Code:</label>
            <input type="text" id="sessionId" placeholder="Enter session code">
        </div>
        <button onclick="createSession()">Create Session</button>
    </div>

    <div id="joinForm">
        <h3>Join Existing Session</h3>
        <div class="form-group">
            <label for="joinSessionId">Session Code:</label>
            <input type="text" id="joinSessionId" placeholder="Enter session code">
        </div>
        <button onclick="joinSession()">Join Session</button>
    </div>

    <div id="status">Status: Not Connected</div>
    <div id="log"></div>

    <script>
        class BloodMNISTTrainer {
            constructor(modelConfig, learningRate = 0.01) {
                this.modelConfig = {
                    checkpointPath: modelConfig.checkpointPath,
                    evalModelPath: modelConfig.evalModelPath,
                    optimizerModelPath: modelConfig.optimizerModelPath,
                    trainingModelPath: modelConfig.trainingModelPath
                };
                this.learningRate = learningRate;
                this.session = null;

            }

            async loadModelFile(path) {
                const response = await fetch(path);
                if (!response.ok) {
                    throw new Error(`Failed to load model file from ${path}: ${response.statusText}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                return new Uint8Array(arrayBuffer);
            }

            async initialize() {
                try {
                    console.log('Loading model files...');
                    
                    // Load all model files
                    const [checkpoint, evalModel, optimizerModel, trainingModel] = await Promise.all([
                        this.loadModelFile(this.modelConfig.checkpointPath),
                        this.loadModelFile(this.modelConfig.evalModelPath),
                        this.loadModelFile(this.modelConfig.optimizerModelPath),
                        this.loadModelFile(this.modelConfig.trainingModelPath)
                    ]);

                    console.log('All model files loaded, creating training session...');

                    // Training configuration
                    const config = {
                        checkpointState: checkpoint.buffer,
                        evalModel: evalModel.buffer,
                        optimizerModel: optimizerModel.buffer,
                        trainingModel: trainingModel.buffer
                    };

                    const response = await fetch(this.modelConfig.checkpointPath);
                    console.log('Checkpoint response:', response.ok, response.status);

                    // Create training session with the configuration
                    this.session = await ort.TrainingSession.create(config);
                    console.log('Training session created successfully');
                    return true;
                } catch (error) {
                    console.error('Error initializing model:', error);
                    throw error;
                }
            }

            async trainEpoch(dataLoader) {
                if (!this.session) {
                    throw new Error('Model not initialized. Call initialize() first.');
                }

                let totalLoss = 0;
                let batchCount = 0;
                
                try {
                    for await (const batch of dataLoader.trainingBatches('train.json')) {
                        const { loss, accuracy } = await this.trainBatch(batch);
                        totalLoss += loss;
                        batchCount++;

                        if (batchCount % 10 === 0) {
                            console.log(`Batch ${batchCount}: Loss = ${loss.toFixed(4)}, Accuracy = ${(accuracy * 100).toFixed(2)}%`);
                        }
                    }

                    const averageLoss = totalLoss / batchCount;
                    console.log(`Epoch completed. Average loss: ${averageLoss.toFixed(4)}`);
                    
                    return averageLoss;
                } catch (error) {
                    console.error('Error during training:', error);
                    throw error;
                }
            }

            async trainBatch(batch) {
                const feeds = {
                    'input': batch.data,
                    'target': batch.labels
                };

                try {
                    // Run training step
                    const results = await this.session.train(feeds);
                    const loss = results.loss;

                    // Run evaluation step
                    const evalResults = await this.session.eval(feeds);
                    const accuracy = this.calculateAccuracy(evalResults.output, batch.labels);

                    return { loss, accuracy };
                } catch (error) {
                    console.error('Error in training batch:', error);
                    throw error;
                }
            }

            calculateAccuracy(output, target) {
                const predictions = output.data;
                const labels = target.data;
                let correct = 0;

                for (let i = 0; i < labels.length; i++) {
                    const label = Number(labels[i]);
                    const pred = predictions.slice(i * 8, (i + 1) * 8); // Assuming 8 classes
                    const predictedClass = pred.indexOf(Math.max(...pred));
                    if (predictedClass === label) {
                        correct++;
                    }
                }

                return correct / labels.length;
            }

            async saveCheckpoint(path) {
                try {
                    const checkpoint = await this.session.getCheckpoint();
                    const blob = new Blob([checkpoint], { type: 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = path;
                    a.click();
                    
                    URL.revokeObjectURL(url);
                    console.log('Checkpoint saved successfully');
                } catch (error) {
                    console.error('Error saving checkpoint:', error);
                    throw error;
                }
            }
        }

        class BloodMNIST {
            static BATCH_SIZE = 64;
            static MAX_NUM_TRAIN_SAMPLES = 60000;
            static MAX_NUM_TEST_SAMPLES = 10000;
            static pixelMax = 255;
            static pixelMean = 0.1307;
            static pixelStd = 0.3081;
            static IMAGE_SIZE = 224; // Updated for blood cell images
            static NUM_CHANNELS = 1; // Grayscale images

            constructor(batchSize = BloodMNIST.BATCH_SIZE, 
                        maxNumTrainSamples = BloodMNIST.MAX_NUM_TRAIN_SAMPLES,
                        maxNumTestSamples = BloodMNIST.MAX_NUM_TEST_SAMPLES) {
                this.batchSize = batchSize;
                this.maxNumTrainSamples = maxNumTrainSamples;
                this.maxNumTestSamples = maxNumTestSamples;
                this.imageSize = BloodMNIST.IMAGE_SIZE * BloodMNIST.IMAGE_SIZE;

                if (batchSize <= 0) {
                    throw new Error("batchSize must be > 0");
                }
            }

            getNumTrainingBatches() {
                return Math.floor(this.maxNumTrainSamples / this.batchSize);
            }

            getNumTestBatches() {
                return Math.floor(this.maxNumTestSamples / this.batchSize);
            }

            *batches(data, labels) {
                const numBatches = Math.floor(data.length / (this.batchSize * this.imageSize));
                console.log(`Creating ${numBatches} batches with size ${this.batchSize} and image size ${BloodMNIST.IMAGE_SIZE}x${BloodMNIST.IMAGE_SIZE}`);
                
                for (let i = 0; i < numBatches; i++) {
                    const start = i * this.batchSize * this.imageSize;
                    const end = start + (this.batchSize * this.imageSize);
                    
                    const batchData = data.slice(start, end);
                    const batchLabels = labels.slice(i * this.batchSize, (i + 1) * this.batchSize);
                    
                    // Create tensor with shape [batch_size, channels, height, width]
                    const tensorData = new Float32Array(batchData);
                    yield {
                        // Shape: [batch_size, channels, height, width]
                        data: new ort.Tensor('float32', tensorData, [
                            this.batchSize, 
                            BloodMNIST.NUM_CHANNELS,
                            BloodMNIST.IMAGE_SIZE,
                            BloodMNIST.IMAGE_SIZE
                        ]),
                        labels: new ort.Tensor('int64', new BigInt64Array(batchLabels.map(BigInt)), [this.batchSize])
                    };
                }
            }

            async loadData(jsonUrl) {
                const response = await fetch(jsonUrl);
                const jsonData = await response.json();
                
                // Convert object with numeric keys to arrays
                const numSamples = Object.keys(jsonData).length;
                const images = [];
                const labels = [];
                
                for (let i = 0; i < numSamples; i++) {
                    const sample = jsonData[i];
                    if (sample) {
                        images.push(...sample.image); // Spread the image array
                        labels.push(sample.label);
                    }
                }

                console.log(`Loaded ${labels.length} samples, image data length: ${images.length}`);
                return { images, labels };
            }

            async *trainingBatches(trainJsonUrl, normalize = true) {
                console.log("Loading training data...");
                const { images, labels } = await this.loadData(trainJsonUrl);
                console.log(`Loaded ${labels.length} training samples`);
                
                const normalizedImages = normalize ? 
                    images.map(pixel => BloodMNIST.normalize(pixel)) : 
                    images;
                yield* this.batches(normalizedImages, labels);
            }

            async *testBatches(testJsonUrl, normalize = true) {
                console.log("Loading test data...");
                const { images, labels } = await this.loadData(testJsonUrl);
                console.log(`Loaded ${labels.length} test samples`);
                
                const normalizedImages = normalize ? 
                    images.map(pixel => BloodMNIST.normalize(pixel)) : 
                    images;
                yield* this.batches(normalizedImages, labels);
            }

            static normalize(pixelValue) {
                return ((pixelValue / this.pixelMax) - this.pixelMean) / this.pixelStd;
            }
        }


        async function main() {
            try{
                const dataLoader = new BloodMNIST();
                const trainer = new BloodMNISTTrainer({
                    checkpointPath: "./public/training_artifacts/checkpoint",
                    evalModelPath: "./public/training_artifacts/eval_model.onnx",
                    optimizerModelPath: "./public/training_artifacts/optimizer_model.onnx",
                    trainingModelPath: "./public/training_artifacts/training_model.onnx"
                });

                await trainer.initialize();

                console.log("Starting training...")
                const loss = await trainer.trainEpoch(dataLoader)

                await trainer.saveCheckpoint("new_checkpoint.ckpt")
            } catch (error) {
                console.error("training fail:", error);
                throw error;
            }
        }

        main().catch(console.error);
    </script>
</body>
</html>