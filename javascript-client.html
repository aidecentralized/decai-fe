<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Torus Node</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web"></script> <!-- ONNX Runtime -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #sessionForm, #joinForm {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="text"],
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        button {
            background-color: #0066cc;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0052a3;
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        #log {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; }
    </style>
</head>
<body>
    <h2>WebRTC Torus Node</h2>
    
    <div id="sessionForm">
        <h3>Create New Session</h3>
        <div class="form-group">
            <label for="maxClients">Number of Clients:</label>
            <input type="number" id="maxClients" min="2" value="4">
        </div>
        <div class="form-group">
            <label for="sessionId">Session Code:</label>
            <input type="text" id="sessionId" placeholder="Enter session code">
        </div>
        <button onclick="createSession()">Create Session</button>
    </div>

    <div id="joinForm">
        <h3>Join Existing Session</h3>
        <div class="form-group">
            <label for="joinSessionId">Session Code:</label>
            <input type="text" id="joinSessionId" placeholder="Enter session code">
        </div>
        <button onclick="joinSession()">Join Session</button>
    </div>

    <div id="status">Status: Not Connected</div>
    <div id="log"></div>

    <script>
        //logging helper    
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `${new Date().toISOString()} - ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;

            if (type === 'info') {
                console.log(message);
            } else {
                console.error(message);
            }
        }

        class TorusNode {
            constructor(signalingServer) {
                this.signalingServer = signalingServer;
                this.connections = new Map();
                this.dataChannels = new Map();
                this.rank = null;
                this.neighbors = null;
                this.connectedPeers = new Set();
                this.pendingConnections = new Set();
                this.expectedConnections = 0;
                this.connectionRetries = new Map();
                this.MAX_RETRIES = 3;
                this.RETRY_DELAY = 2000;
                this.sessionId = null;

                // model for ONNX runtime
                this.model = null;

                log('Initializing TorusNode...');
            }

            /*
            
            Helpers

            */


            updateStatus(message) {
                document.getElementById('status').textContent = `Status: ${message}`;
            }

            /*
            
            Decentralized Communication

            */

            async connect(sessionInfo) {
                try {
                    this.ws = new WebSocket(this.signalingServer);
                    this.ws.onmessage = this.handleWsMessage.bind(this);
                    this.ws.onopen = () => {
                        log('Connected to signaling server');
                        this.ws.send(JSON.stringify({
                            // type: 'session_action',
                            type: sessionInfo.type,
                            sessionId: sessionInfo.sessionId,
                            maxClients: sessionInfo.maxClients,
                            clientType: 'javascript'
                        }));
                    };
                } catch (error) {
                    log(`WebSocket connection error: ${error}`, 'error');
                }
            }

            async handleWsMessage(event) {
                const data = JSON.parse(event.data);
                log(`Received ${data.type} message`);

                switch (data.type) {
                    case 'session_created':
                        this.updateStatus(`Session created. Waiting for ${data.remainingClients} more clients...`);
                        this.sessionId = data.sessionId;
                        break;
                    case 'session_joined':
                        this.updateStatus(`Joined session. Waiting for ${data.remainingClients} more clients...`);
                        this.sessionId = data.sessionId;
                        break;
                    case 'session_ready':
                        this.updateStatus('Session ready! Establishing connections...');
                        break;
                    case 'session_error':
                        this.updateStatus(`Session Error: ${data.message}`);
                        log(data.message, 'error');
                        break;
                    case 'topology':
                        await this.handleTopology(data);
                        break;
                    case 'signal':
                        await this.handleSignaling(data);
                        break;
                    case 'network_ready':
                        this.updateStatus('Network Ready');
                        break;
                }
            }

            async handleTopology(data) {
                this.rank = data.rank;
                const newNeighbors = data.neighbors;
                log(`Received topology. Rank: ${this.rank}, Neighbors: ${JSON.stringify(newNeighbors)}`);

                if (this.neighbors) {
                    const oldNeighbors = new Set(Object.values(this.neighbors));
                    const newNeighborSet = new Set(Object.values(newNeighbors));
                    for (const rank of oldNeighbors) {
                        if (!newNeighborSet.has(rank)) {
                            await this.cleanupConnection(rank);
                        }
                    }
                }

                this.neighbors = newNeighbors;
                this.expectedConnections = Object.keys(newNeighbors).length;
                this.updateStatus(`Connected (Rank ${this.rank})`);

                // Initiate connections to higher-ranked neighbors
                for (const neighborRank of Object.values(newNeighbors)) {
                    if (neighborRank > this.rank && 
                        !this.connections.has(neighborRank) && 
                        !this.pendingConnections.has(neighborRank)) {
                        log(`Initiating connection to ${neighborRank}`);
                        this.pendingConnections.add(neighborRank);
                        this.initiateConnection(neighborRank);
                    }
                }
            }

            createPeerConnection() {
                const config = {
                    iceServers: [{
                        urls: [
                            'stun:stun.l.google.com:19302',
                            'stun:stun1.l.google.com:19302'
                        ]
                    }]
                };

                const pc = new RTCPeerConnection(config);
                
                pc.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${pc.iceConnectionState}`);
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('ICE candidate generated');
                    }
                };

                return pc;
            }

            async initiateConnection(targetRank) {
                try {
                    const pc = this.createPeerConnection();
                    this.connections.set(targetRank, pc);

                    // Create data channel
                    const channel = pc.createDataChannel(`chat-${this.rank}-${targetRank}`);
                    this.setupDataChannel(channel, targetRank);

                    // Create and set local description
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);

                    // Wait for ICE gathering
                    await new Promise(resolve => {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                setTimeout(checkState, 1000);
                            }
                        };
                        checkState();
                    });

                    // Send offer
                    await this.sendSignaling(targetRank, {
                        type: 'offer',
                        sdp: pc.localDescription.sdp
                    });

                } catch (error) {
                    log(`Failed to initiate connection to ${targetRank}: ${error}`, 'error');
                    await this.handleConnectionFailure(targetRank);
                }
            }

            setupDataChannel(channel, peerRank) {
                this.dataChannels.set(peerRank, channel);

                channel.onopen = () => {
                    log(`Data channel opened with peer ${peerRank}`);
                    this.onPeerConnected(peerRank);
                    this.startFederatedTrainingLoop(peerRank);
                };

                channel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'ping') {
                            log(`Received ping from ${peerRank}`);
                            channel.send(JSON.stringify({
                                type: 'pong',
                                timestamp: data.timestamp,
                                respondedAt: Date.now()
                            }));
                        } else if (data.type === 'pong') {
                            const rtt = Date.now() - data.timestamp;
                            log(`Received pong from ${peerRank}, RTT: ${rtt}ms`);
                        } else if (data.type === "weights") { // handle recieved weights
                            log(`Recieved weights from ${peerRank}`);
                            this.importWeights(data.weights);
                        }
                    } catch (error) {
                        log(`Failed to parse message from ${peerRank}: ${error}`, 'error');
                    }
                };
            }

            /* Old Pinging Loop, Replace this w/ Training Loop
            startPingLoop(peerRank) {
                const sendPing = () => {
                    const channel = this.dataChannels.get(peerRank);
                    if (channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                };

                setInterval(sendPing, 5000);
            }
            */

            async startFederatedTrainingLoop(peerRank) {
                await this.loadDummyModel();

                // loop to train and then send weights to peer
                const trainAndSend = () => {
                    log("Running local training loop...");
                    this.model.train();

                    log(`Sending weights to connected peer rank ${peerRank}...`);
                    this.sendWeights(peerRank);
                }

                setInterval(trainAndSend, 5000);
            }



            async handleSignaling(message) {
                const senderRank = message.senderRank;
                const data = message.data;

                try {
                    let pc = this.connections.get(senderRank);
                    if (!pc) {
                        pc = this.createPeerConnection();
                        this.connections.set(senderRank, pc);

                        pc.ondatachannel = (event) => {
                            this.setupDataChannel(event.channel, senderRank);
                        };
                    }

                    if (data.type === 'offer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: data.sdp
                        }));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await this.sendSignaling(senderRank, {
                            type: 'answer',
                            sdp: answer.sdp,
                        });
                    } else if (data.type === 'answer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdp
                        }));
                    } else if (data.type === 'candidate') {
                        await pc.addIceCandidate({
                            candidate: data.candidate,
                            sdpMLineIndex: 0,
                            sdpMid: '0'
                        });
                    }
                } catch (error) {
                    log(`Error handling signaling message: ${error}`, 'error');
                }
            }

            async sendSignaling(targetRank, data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    await this.ws.send(JSON.stringify({
                        type: 'signal',
                        targetRank: targetRank,
                        data: data,
                        sessionId: this.sessionId
                    }));
                }
            }

            onPeerConnected(peerRank) {
                this.connectedPeers.add(peerRank);
                this.pendingConnections.delete(peerRank);
                log(`Connected to peer ${peerRank}. Connected: ${this.connectedPeers.size}/${this.expectedConnections}`);

                this.ws.send(JSON.stringify({
                    type: 'connection_established',
                    peerRank: peerRank,
                    sessionId: this.sessionId
                }));
            }

            async handleConnectionFailure(targetRank) {
                const retryCount = this.connectionRetries.get(targetRank) || 0;
                if (retryCount < this.MAX_RETRIES) {
                    this.connectionRetries.set(targetRank, retryCount + 1);
                    await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY * (retryCount + 1)));
                    if (!this.connectedPeers.has(targetRank)) {
                        await this.cleanupConnection(targetRank);
                        this.initiateConnection(targetRank);
                    }
                } else {
                    log(`Max retries reached for ${targetRank}`, 'error');
                    await this.cleanupConnection(targetRank);
                }
            }

            async cleanupConnection(rank) {
                try {
                    const pc = this.connections.get(rank);
                    if (pc) {
                        const channel = this.dataChannels.get(rank);
                        if (channel) {
                            channel.close();
                            this.dataChannels.delete(rank);
                        }
                        pc.close();
                        this.connections.delete(rank);
                    }

                    this.pendingConnections.delete(rank);
                    this.connectedPeers.delete(rank);
                    log(`Cleaned up connection to peer ${rank}`);
                } catch (error) {
                    log(`Error during connection cleanup for peer ${rank}: ${error}`, 'error');
                }
            }

            /*

            Begin Training Methods

            */

            // loads ONNX model
            async loadDummyModel() {
                log("Creating a dummy ONNX model...");
                this.model = {
                    weights: [Math.random(), Math.random()], // get random dummy weights

                    // define training function (adds random noise for now)
                    train: function () {
                        log("Training dummy ONNX model...");
                        this.weights = this.weights.map((w) => w + Math.random());
                    },
                    
                    // getter for the model weights
                    getWeights: function () {
                        return this.weights;
                    },
                };
                log("Dummy ONNX model created.");
            }

            // export the model weights
            exportWeights() {
                log("Exporting weights...");
                return this.model.getWeights();
            }

            // import model weights that we get from a peer
            importWeights(recievedWeights) {
                log("Importing weights...");
                
                // average our weights with the recieved peer weights
                this.model.weights = this.model.weights.map((w, i) => w + recievedWeights[i] / 2);

                log(`Updated weights.`);
            }

            // helper for sending the weights across peer datachannel
            sendWeights = (peerRank) => {
                const channel = this.dataChannels.get(peerRank);

                if (channel && channel.readyState === "open") {
                    // send our weights to the peer
                    channel.send(JSON.stringify({
                        type: "weights",
                        weights: this.exportWeights(),
                        timestamp: Date.now(),
                    }));
                }
            }
        }

        /*

        Session Handling

        */

        let node = null;

        function createSession() {
            const maxClients = document.getElementById('maxClients').value;
            const sessionId = document.getElementById('sessionId').value || generateSessionId();
            document.getElementById('sessionId').value = sessionId;

            node = new TorusNode('ws://localhost:8080');
            node.connect({
                type: 'create_session',
                sessionId: sessionId,
                maxClients: parseInt(maxClients)
            });
        }

        function joinSession() {
            const sessionId = document.getElementById('joinSessionId').value;
            if (!sessionId) {
                alert('Please enter a session code');
                return;
            }

            node = new TorusNode('ws://localhost:8080');
            node.connect({
                type: 'join_session',
                sessionId: sessionId
            });
        }

        function generateSessionId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // Hide the forms once connected
        function hideSessionForms() {
            document.getElementById('sessionForm').style.display = 'none';
            document.getElementById('joinForm').style.display = 'none';
        }
    </script>
</body>
</html>