<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decentralized Learning Node</title>
  <script src="https://unpkg.com/peerjs@1.3.2/dist/peerjs.min.js"></script> <!-- PeerJS CDN -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web"></script> <!-- ONNX Runtime -->
  <style>
    body { font-family: Arial, sans-serif; text-align: center; }
  </style>
</head>
<body>
  <h1>Decentralized Learning Node</h1>
  <p id="status">Connecting to PeerJS signaling server...</p>
  <p id="peer-id">Peer ID: -</p>
  <p id="peers">Peers: None</p>

  <script>
    const peerServerHost = "localhost"; // Change to your PeerJS server host
    const peerServerPort = 9000; // Ensure this matches the PeerJS server port
    const signalingPath = "/myapp"; // Ensure this matches the PeerJS server path

    let peer;
    let connections = {};
    let connectedPeers = [];

    // Initialize PeerJS
    function connectPeerServer() {
      peer = new Peer(undefined, {
        host: peerServerHost,
        port: peerServerPort,
        path: signalingPath,
      });

      // When connected to PeerJS server
      peer.on("open", (id) => {
        console.log("Connected to PeerJS server with ID:", id);
        document.getElementById("status").textContent = `Connected to PeerJS signaling server`;
        document.getElementById("peer-id").textContent = `Peer ID: ${id}`;
      });

      // Listen for incoming connections
      peer.on("connection", (conn) => {
        if (!connections[conn.peer]) {
          connections[conn.peer] = conn;
          connectedPeers.push(conn.peer);
          updatePeers();
        }

        conn.on("data", (data) => {
          console.log("Received data from peer:", conn.peer, data);

          if (data.type === "weights") {
            console.log("Received weights from peer:", data.weights);
            importWeights(data.weights);
          }
        });

        conn.on("close", () => {
          console.log("Connection closed with peer:", conn.peer);
          delete connections[conn.peer];
          connectedPeers = connectedPeers.filter((peerId) => peerId !== conn.peer);
          updatePeers();
        });
      });

      // Handle errors
      peer.on("error", (err) => {
        console.error("PeerJS Error:", err);
      });
    }

    // Update peer list dynamically
    function updatePeers() {
      const peerList = connectedPeers.join(", ") || "None";
      document.getElementById("peers").textContent = `Peers: ${peerList}`;
      console.log("Updated peers:", connectedPeers);
    }

    // Connect to all known peers
    function connectToPeers() {
      if (peer.disconnected) return;

      // Iterate through all peer IDs from PeerJS signaling server
      const availablePeers = peer.listAllPeers((peerIds) => {
        peerIds.forEach((peerId) => {
          if (peerId !== peer.id && !connections[peerId]) {
            const conn = peer.connect(peerId);
            conn.on("open", () => {
              console.log("Connected to peer:", peerId);
              connections[peerId] = conn;
              connectedPeers.push(peerId);
              updatePeers();
            });

            conn.on("data", (data) => {
              console.log("Received data from peer:", peerId, data);

              if (data.type === "weights") {
                console.log("Received weights from peer:", data.weights);
                importWeights(data.weights);
              }
            });

            conn.on("close", () => {
              console.log("Connection closed with peer:", peerId);
              delete connections[peerId];
              connectedPeers = connectedPeers.filter((id) => id !== peerId);
              updatePeers();
            });
          }
        });
      });
    }

    // Simulate a dummy ONNX model
    let model;
    async function loadDummyModel() {
      console.log("Creating a dummy ONNX model...");
      model = {
        weights: [Math.random(), Math.random()], // Dummy weights
        train: function () {
          console.log("Training dummy model...");
          this.weights = this.weights.map((w) => w + Math.random());
        },
        getWeights: function () {
          return this.weights;
        },
      };
      console.log("Dummy model created.");
    }

    // Export model weights
    function exportWeights() {
      console.log("Exporting weights...");
      return model.getWeights();
    }

    // Import received weights
    function importWeights(receivedWeights) {
      console.log("Importing weights...");
      model.weights = model.weights.map((w, i) => (w + receivedWeights[i]) / 2);
      console.log("Updated weights:", model.weights);
    }

    // Federated training loop
    async function startFederatedTraining() {
      await loadDummyModel();

      setInterval(() => {
        console.log("Training locally...");
        model.train();

        console.log("Starting weight exchange...");
        exchangeWeights();
      }, 5000); // Train and exchange weights every 5 seconds
    }

    // Exchange weights with connected peers
    function exchangeWeights() {
      connectedPeers.forEach((peerId) => {
        const conn = connections[peerId];
        if (conn && conn.open) {
          const localWeights = exportWeights();
          conn.send({
            type: "weights",
            weights: localWeights,
          });
          console.log("Sent weights to peer:", peerId);
        }
      });
    }

    // Start application
    connectPeerServer();
    setTimeout(connectToPeers, 3000); // Wait for peers to connect before listing
    startFederatedTraining();
  </script>
</body>
</html>
