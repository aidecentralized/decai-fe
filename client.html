<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Federated Learning Node</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web"></script>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; }
  </style>
</head>
<body>
  <h1>Federated Learning Node</h1>
  <p id="status">Connecting...</p>
  <p id="rank">Rank: -</p>
  <p id="peers">Peers: None</p>

  <script>
    const socket = new WebSocket("ws://localhost:8080");
    let rank;
    let peers = {};

    let model; // Placeholder for the ONNX model
    const modelPath = './path-to-your-model.onnx'; // Update this to your model path

    // Initial handshake with the server
    socket.onopen = () => {
        document.getElementById("status").textContent = "Connected to signaling server";
        console.log("Connected to the signaling server");
    };

    socket.onmessage = (message) => {
        const data = JSON.parse(message.data);

        // Receive rank and peer list in initial handshake
        if (data.rank !== undefined) {
            rank = data.rank;
            document.getElementById("rank").textContent = `Rank: ${rank}`;
            console.log(`Assigned rank: ${rank}`);
        }

        // Update peers list
        if (data.peers) {
            peers = data.peers;
            const peersText = Object.entries(peers)
              .map(([rank, { ip, port }]) => `Rank ${rank} - IP: ${ip}, Port: ${port}`)
              .join(", ");
            document.getElementById("peers").textContent = `Peers: ${peersText}`;
            console.log("Peers list updated:", peers);
        }
    };

    socket.onclose = () => {
        document.getElementById("status").textContent = "Disconnected from signaling server";
        console.log("Disconnected from the signaling server");
    };

    // Load the ONNX model
    async function loadModel() {
        console.log("Loading ONNX model...");
        model = await ort.InferenceSession.create(modelPath);
        console.log("Model loaded.");
    }

    // Train the model (dummy implementation)
    async function trainModel() {
        console.log("Training locally...");
        const input = new ort.Tensor('float32', new Float32Array([1, 2, 3, 4]), [4, 1]); // Dummy input
        const label = new ort.Tensor('float32', new Float32Array([1, 3, 5, 7]), [4, 1]); // Dummy labels

        const feeds = { input: input, labels: label };
        const results = await model.run(feeds); // Run training step
        console.log("Training results:", results);

        return exportWeights(); // Return updated weights
    }

    // Export model weights (simulate ONNX weights as JSON)
    function exportWeights() {
        // Simulate weight extraction (you need to implement a real method for ONNX)
        console.log("Exporting weights...");
        return [{ data: [/* Simulated weight data */], shape: [/* Weight shape */] }];
    }

    // Import received weights
    function importWeights(receivedWeights) {
        console.log("Importing received weights...");
        // Simulate applying received weights (you need to implement this for ONNX)
    }

    // Exchange weights with a random peer
    async function exchangeWeights() {
        const peerKeys = Object.keys(peers).filter((p) => p != rank); // Exclude self
        if (peerKeys.length === 0) return;

        const randomPeerRank = peerKeys[Math.floor(Math.random() * peerKeys.length)];
        const randomPeer = peers[randomPeerRank];

        console.log(`Exchanging weights with Peer Rank ${randomPeerRank}`);
        const localWeights = await exportWeights();

        // Send local weights to peer
        socket.send(JSON.stringify({ type: 'weights', to: randomPeerRank, data: localWeights }));

        // Simulate receiving weights from the peer
        const receivedWeights = await simulatePeerWeights(); // Replace with real WebSocket response handling
        averageWeights(localWeights, receivedWeights);
    }

    // Simulate receiving weights from a peer
    async function simulatePeerWeights() {
        return [{ data: [/* Simulated peer weight data */], shape: [/* Weight shape */] }];
    }

    // Average weights
    function averageWeights(localWeights, peerWeights) {
        console.log("Averaging weights...");
        const averagedWeights = localWeights.map((localWeight, i) => {
            const localData = localWeight.data;
            const peerData = peerWeights[i].data;

            const averagedData = localData.map((value, index) => (value + peerData[index]) / 2);
            return { data: averagedData, shape: localWeight.shape };
        });

        importWeights(averagedWeights); // Apply the averaged weights
    }

    // Training loop
    async function startFederatedTraining() {
        await loadModel();
        while (true) {
            console.log("Starting local training...");
            await trainModel();

            console.log("Starting weight exchange...");
            await exchangeWeights();
        }
    }

    // Start the federated training process
    startFederatedTraining();
  </script>
</body>
</html>
