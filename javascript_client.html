<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Torus Node</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #fff;
        }
        #log {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .log-info { color: #0066cc; }
        .log-error { color: #cc0000; }
    </style>
</head>
<body>
    <h2>WebRTC Torus Node</h2>
    <div id="status">Status: Connecting...</div>
    <div id="log"></div>

    <script>
        class TorusNode {
            constructor(signalingServer) {
                this.signalingServer = signalingServer;
                this.connections = new Map();
                this.dataChannels = new Map();
                this.rank = null;
                this.neighbors = null;
                this.connectedPeers = new Set();
                this.pendingConnections = new Set();
                this.expectedConnections = 0;
                this.connectionRetries = new Map();
                this.MAX_RETRIES = 3;
                this.RETRY_DELAY = 2000;

                this.log('Initializing TorusNode...');
            }

            log(message, type = 'info') {
                const logDiv = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `${new Date().toISOString()} - ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;

                if (type === 'info') {
                    console.log(message);
                } else {
                    console.error(message);
                }
            }

            updateStatus(message) {
                document.getElementById('status').textContent = `Status: ${message}`;
            }

            async connect() {
                try {
                    this.ws = new WebSocket(this.signalingServer);
                    this.ws.onmessage = this.handleWsMessage.bind(this);
                    this.ws.onopen = () => {
                        this.log('Connected to signaling server');
                        this.ws.send(JSON.stringify({
                            type: 'ready',
                            clientType: 'javascript'
                        }));
                    };
                } catch (error) {
                    this.log(`WebSocket connection error: ${error}`, 'error');
                }
            }

            async handleWsMessage(event) {
                const data = JSON.parse(event.data);
                this.log(`Received ${data.type} message`);

                switch (data.type) {
                    case 'topology':
                        await this.handleTopology(data);
                        break;
                    case 'signal':
                        await this.handleSignaling(data);
                        break;
                    case 'network_ready':
                        this.updateStatus('Network Ready');
                        break;
                }
            }

            async handleTopology(data) {
                this.rank = data.rank;
                const newNeighbors = data.neighbors;
                this.log(`Received topology. Rank: ${this.rank}, Neighbors: ${JSON.stringify(newNeighbors)}`);

                if (this.neighbors) {
                    const oldNeighbors = new Set(Object.values(this.neighbors));
                    const newNeighborSet = new Set(Object.values(newNeighbors));
                    for (const rank of oldNeighbors) {
                        if (!newNeighborSet.has(rank)) {
                            await this.cleanupConnection(rank);
                        }
                    }
                }

                this.neighbors = newNeighbors;
                this.expectedConnections = Object.keys(newNeighbors).length;
                this.updateStatus(`Connected (Rank ${this.rank})`);

                // Initiate connections to higher-ranked neighbors
                for (const neighborRank of Object.values(newNeighbors)) {
                    if (neighborRank > this.rank && 
                        !this.connections.has(neighborRank) && 
                        !this.pendingConnections.has(neighborRank)) {
                        this.log(`Initiating connection to ${neighborRank}`);
                        this.pendingConnections.add(neighborRank);
                        this.initiateConnection(neighborRank);
                    }
                }
            }

            createPeerConnection() {
                const config = {
                    iceServers: [{
                        urls: [
                            'stun:stun.l.google.com:19302',
                            'stun:stun1.l.google.com:19302'
                        ]
                    }]
                };

                const pc = new RTCPeerConnection(config);
                
                pc.oniceconnectionstatechange = () => {
                    this.log(`ICE connection state: ${pc.iceConnectionState}`);
                };

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.log('ICE candidate generated');
                    }
                };

                return pc;
            }

            async initiateConnection(targetRank) {
                try {
                    const pc = this.createPeerConnection();
                    this.connections.set(targetRank, pc);

                    // Create data channel
                    const channel = pc.createDataChannel(`chat-${this.rank}-${targetRank}`);
                    this.setupDataChannel(channel, targetRank);

                    // Create and set local description
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);

                    // Wait for ICE gathering
                    await new Promise(resolve => {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                setTimeout(checkState, 1000);
                            }
                        };
                        checkState();
                    });

                    // Send offer
                    await this.sendSignaling(targetRank, {
                        type: 'offer',
                        sdp: pc.localDescription.sdp
                    });

                } catch (error) {
                    this.log(`Failed to initiate connection to ${targetRank}: ${error}`, 'error');
                    await this.handleConnectionFailure(targetRank);
                }
            }

            setupDataChannel(channel, peerRank) {
                this.dataChannels.set(peerRank, channel);

                channel.onopen = () => {
                    this.log(`Data channel opened with peer ${peerRank}`);
                    this.onPeerConnected(peerRank);
                    this.startPingLoop(peerRank);
                };

                channel.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'ping') {
                            this.log(`Received ping from ${peerRank}`);
                            channel.send(JSON.stringify({
                                type: 'pong',
                                timestamp: data.timestamp,
                                respondedAt: Date.now()
                            }));
                        } else if (data.type === 'pong') {
                            const rtt = Date.now() - data.timestamp;
                            this.log(`Received pong from ${peerRank}, RTT: ${rtt}ms`);
                        }
                    } catch (error) {
                        this.log(`Failed to parse message from ${peerRank}: ${error}`, 'error');
                    }
                };
            }

            startPingLoop(peerRank) {
                const sendPing = () => {
                    const channel = this.dataChannels.get(peerRank);
                    if (channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify({
                            type: 'ping',
                            timestamp: Date.now()
                        }));
                    }
                };

                setInterval(sendPing, 5000);
            }

            async handleSignaling(message) {
                const senderRank = message.senderRank;
                const data = message.data;

                try {
                    let pc = this.connections.get(senderRank);
                    if (!pc) {
                        pc = this.createPeerConnection();
                        this.connections.set(senderRank, pc);

                        pc.ondatachannel = (event) => {
                            this.setupDataChannel(event.channel, senderRank);
                        };
                    }

                    if (data.type === 'offer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'offer',
                            sdp: data.sdp
                        }));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await this.sendSignaling(senderRank, {
                            type: 'answer',
                            sdp: answer.sdp
                        });
                    } else if (data.type === 'answer') {
                        await pc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdp
                        }));
                    } else if (data.type === 'candidate') {
                        await pc.addIceCandidate({
                            candidate: data.candidate,
                            sdpMLineIndex: 0,
                            sdpMid: '0'
                        });
                    }
                } catch (error) {
                    this.log(`Error handling signaling message: ${error}`, 'error');
                }
            }

            async sendSignaling(targetRank, data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    await this.ws.send(JSON.stringify({
                        type: 'signal',
                        targetRank: targetRank,
                        data: data
                    }));
                }
            }

            onPeerConnected(peerRank) {
                this.connectedPeers.add(peerRank);
                this.pendingConnections.delete(peerRank);
                this.log(`Connected to peer ${peerRank}. Connected: ${this.connectedPeers.size}/${this.expectedConnections}`);

                this.ws.send(JSON.stringify({
                    type: 'connection_established',
                    peerRank: peerRank
                }));
            }

            async handleConnectionFailure(targetRank) {
                const retryCount = this.connectionRetries.get(targetRank) || 0;
                if (retryCount < this.MAX_RETRIES) {
                    this.connectionRetries.set(targetRank, retryCount + 1);
                    await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY * (retryCount + 1)));
                    if (!this.connectedPeers.has(targetRank)) {
                        await this.cleanupConnection(targetRank);
                        this.initiateConnection(targetRank);
                    }
                } else {
                    this.log(`Max retries reached for ${targetRank}`, 'error');
                    await this.cleanupConnection(targetRank);
                }
            }

            async cleanupConnection(rank) {
                try {
                    const pc = this.connections.get(rank);
                    if (pc) {
                        const channel = this.dataChannels.get(rank);
                        if (channel) {
                            channel.close();
                            this.dataChannels.delete(rank);
                        }
                        pc.close();
                        this.connections.delete(rank);
                    }

                    this.pendingConnections.delete(rank);
                    this.connectedPeers.delete(rank);
                    this.log(`Cleaned up connection to peer ${rank}`);
                } catch (error) {
                    this.log(`Error during connection cleanup for peer ${rank}: ${error}`, 'error');
                }
            }
        }

        // Start the client when the page loads
        window.onload = () => {
            const node = new TorusNode('ws://localhost:8080');
            node.connect();
        };
    </script>
</body>
</html>